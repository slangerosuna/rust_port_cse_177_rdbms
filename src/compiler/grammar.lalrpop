use crate::*;
use crate::compiler::ast::*;
use crate::compiler::Token;

grammar;

pub Query: Query = {
#[precedence(level = "0")]
  "(" <q: Query> ")" => q,
  <tables: NameList> => {
      Query::Scan {
          table_names: tables
      }
  },

#[precedence(level = "1")]
  "SELECT" <atts: SelectAtts> "FROM" <sub_query: Query> "WHERE" <clause: Condition> => {
      Query::Select {
          atts,
          from: Box::new(sub_query),
          r#where: Some(clause),
          distinct: false,
      }
  },
  "SELECT" "DISTINCT" <atts: SelectAtts> "FROM" <sub_query: Query> "WHERE" <clause: Condition> => {
      Query::Select {
          atts,
          from: Box::new(sub_query),
          r#where: Some(clause),
          distinct: true,
      }
  },
#[precedence(level = "2")]
  "SELECT" <atts: SelectAtts> "FROM" <sub_query: Query> => {
      Query::Select {
          atts,
          from: Box::new(sub_query),
          r#where: None,
          distinct: false,
      }
  },
  "SELECT" "DISTINCT" <atts: SelectAtts> "FROM" <sub_query: Query> => {
      Query::Select {
          atts,
          from: Box::new(sub_query),
          r#where: None,
          distinct: true,
      }
  },
#[precedence(level = "3")]
  <sub_query: Query> "GROUP" "BY" <group_atts: GroupByAtts> => {
      Query::GroupBy {
          atts: group_atts,
          from: Box::new(sub_query),
      }
  },
  <sub_query: Query> "ORDER" "BY" <order_atts: OrderByAtts> "ASC" => {
      Query::OrderBy {
          asc: true,
          atts: order_atts,
          from: Box::new(sub_query),
      }
  },
  <sub_query: Query> "ORDER" "BY" <order_atts: OrderByAtts> "DESC" => {
      Query::OrderBy {
          asc: false,
          atts: order_atts,
          from: Box::new(sub_query),
      }
  },
  <sub_query: Query> "ORDER" "BY" <order_atts: OrderByAtts> => {
      Query::OrderBy {
          asc: true,
          atts: order_atts,
          from: Box::new(sub_query),
      }
  },
#[precedence(level="1")] #[assoc(side="left")]
  <left: Query> "INNER" "JOIN" <right: Query> "ON" <cond: Condition> => {
      Query::Join {
          join_type: JoinType::Inner,
          left: Box::new(left),
          right: Box::new(right),
          on: Some(cond),
      }
  },
  <left: Query> "LEFT" "JOIN" <right: Query> "ON" <cond: Condition> => {
      Query::Join {
          join_type: JoinType::LeftOuter,
          left: Box::new(left),
          right: Box::new(right),
          on: Some(cond),
      }
  },
  <left: Query> "RIGHT" "JOIN" <right: Query> "ON" <cond: Condition> => {
      Query::Join {
          join_type: JoinType::RightOuter,
          left: Box::new(left),
          right: Box::new(right),
          on: Some(cond),
      }
  },
  <left: Query> "FULL" "OUTER" "JOIN" <right: Query> "ON" <cond: Condition> => {
      Query::Join {
          join_type: JoinType::FullOuter,
          left: Box::new(left),
          right: Box::new(right),
          on: Some(cond),
      }
  },
};

pub SelectAtts: SelectAtts = {
    "(" <atts: SelectAtts> ")" => atts,
    "*" => SelectAtts::Star,
    <names: NameList> => SelectAtts::Atts(names),
};

pub NameList: Vec<String> = {
    <mut names: NameList> "," <name: Name> => {
        names.push(name);
        names
    },
    <name: Name> => vec![name],
};

pub ConditionExpr: ConditionExpr = {
    <expr: ArithExpr> => ConditionExpr::Arith(expr),
    <string: Str> => ConditionExpr::StrLit(string),
}

pub Condition: Condition = {
#[precedence(level="0")]
    "(" <cond: Condition> ")" => cond,
    "TRUE" => Condition::BoolLiteral(true),
    "FALSE" => Condition::BoolLiteral(false),

#[precedence(level = "1")]
    <left: ConditionExpr> "<" <right: ConditionExpr> => Condition::Comparison(Box::new(left), Box::new(right), CompOp::Less),
    <left: ConditionExpr> "<=" <right: ConditionExpr> => Condition::Comparison(Box::new(left), Box::new(right), CompOp::LessEqual),
    <left: ConditionExpr> ">" <right: ConditionExpr> => Condition::Comparison(Box::new(left), Box::new(right), CompOp::Greater),
    <left: ConditionExpr> ">=" <right: ConditionExpr> => Condition::Comparison(Box::new(left), Box::new(right), CompOp::GreaterEqual),
    <left: ConditionExpr> "=" <right: ConditionExpr> => Condition::Comparison(Box::new(left), Box::new(right), CompOp::Equal),
    <left: ConditionExpr> "IS" <right: ConditionExpr> => Condition::Comparison(Box::new(left), Box::new(right), CompOp::Equal),

#[precedence(level = "2")]
    "NOT" <cond: Condition> => Condition::Not(Box::new(cond)),

#[precedence(level = "3")] #[assoc(side="left")]
    <left: Condition> "AND" <right: Condition> => Condition::And(Box::new(left), Box::new(right)),

#[precedence(level = "4")] #[assoc(side="left")]
    <left: Condition> "OR" <right: Condition> => Condition::Or(Box::new(left), Box::new(right)),
};

pub GroupByAtts: GroupByAtts = {
    "(" <atts: GroupByAtts> ")" => atts,
    <names: NameList> => GroupByAtts { atts: names },
};

pub OrderByAtts: OrderByAtts = {
    "(" <atts: OrderByAtts> ")" => atts,
    <names: NameList> => OrderByAtts { atts: names },
};

pub ArithExpr: ArithExpr = {
#[precedence(level="0")]
  "(" <e: ArithExpr> ")" => e,
  <n: Name> => ArithExpr::Load(n),
  <i: Integer> => ArithExpr::IntLit(i.parse().unwrap()),
  <f: Float> => ArithExpr::FltLit(f.parse().unwrap()),

#[precedence(level="1")] #[assoc(side="left")]
  <r:ArithExpr> "/" <l:ArithExpr> => ArithExpr::Div(Box::new(r), Box::new(l)),
  <r:ArithExpr> "*" <l:ArithExpr> => ArithExpr::Mul(Box::new(r), Box::new(l)),

#[precedence(level="2")] #[assoc(side="left")]
  <r:ArithExpr> "+" <l:ArithExpr> => ArithExpr::Add(Box::new(r), Box::new(l)),
  <r:ArithExpr> "-" <l:ArithExpr> => ArithExpr::Sub(Box::new(r), Box::new(l)),
}

extern {
    type Location = usize;
    type Error = LalrpopError;

    enum Token {
        // Keywords
        "SELECT" => Token::Select,
        "FROM" => Token::From,
        "WHERE" => Token::Where,
        "SUM" => Token::Sum,
        "AND" => Token::And,
        "GROUP" => Token::Group,
        "ORDER" => Token::Order,
        "ASC" => Token::Asc,
        "DESC" => Token::Desc,
        "DISTINCT" => Token::Distinct,
        "BY" => Token::By,
        "LEFT" => Token::Left,
        "RIGHT" => Token::Right,
        "FULL" => Token::Full,
        "INNER" => Token::Inner,
        "OUTER" => Token::Outer,
        "JOIN" => Token::Join,
        "AS" => Token::As,
        "ON" => Token::On,
        "AND" => Token::And,
        "OR" => Token::Or,
        "NOT" => Token::Not,
        "IS" => Token::Is,
        "NULL" => Token::Null,
        "IN" => Token::In,
        "LIKE" => Token::Like,
        "BETWEEN" => Token::Between,
        "EXISTS" => Token::Exists,
        "ALL" => Token::All,
        "ANY" => Token::Any,
        "UNION" => Token::Union,
        "INTERSECT" => Token::Intersect,
        "EXCEPT" => Token::Except,
        "UPDATE" => Token::Update,
        "SET" => Token::Set,
        "DELETE" => Token::Delete,
        "INSERT" => Token::Insert,
        "INTO" => Token::Into,
        "VALUES" => Token::Values,
        "CREATE" => Token::Create,
        "DROP" => Token::Drop,
        "TABLE" => Token::Table,
        "VIEW" => Token::View,
        "TRUE" => Token::True,
        "FALSE" => Token::False,

        // Operators and punctuation
        "(" => Token::LParen,
        ")" => Token::RParen,
        "<" => Token::Lt,
        "<=" => Token::Lte,
        ">" => Token::Gt,
        ">=" => Token::Gte,
        "=" => Token::Eq,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "/" => Token::Slash,
        "*" => Token::Star,
        "," => Token::Comma,

        // Values
        Name => Token::Name(<String>),
        Integer => Token::Integer(<String>),
        Float => Token::Float(<String>),
        Str => Token::Str(<String>),
    }
}

